# java-基础

- java 语言的三大特性

  - 封装
    -  隐藏 内部 实现细节 对外提供接口

  - 继承 
    - extends 关键字

  - 多态

    - 编译时多态 
      - 方法的重载

    - 运行时多态
      - 程序中定义的对象所引用的具体类型在运行期间才能确定

- 条件 继承 重写(override) 向上转型

- 五大原则

  - 单一职责原则SRP(Single Responsibility Principle)

  - 开放封闭df原则OCP(Open－Close Principle)

  - 里式替换原则LSP(the Liskov Substitution Principle LSP)

  - 依赖倒置原则DIP(the Dependency Inversion Principle DIP)

  - 接口分离原则ISP(the Interface Segregation Principle ISP)

- 抽象中的关系

  - 继承关系
    - is-A

  - 实现关系

  - 聚合关系

  - 彼此之间非强关联 如电脑 鼠标 作为一个整体

  - 组合关系

  - 批次之间强关联 如公司和部门

  - 关联关系

- 一对多 多对一这样的关联关系
  - 修饰符权限

|         | 本类 | 同包(子类和无关类) | 不同包(子类) | 不同包(无关类) |
| ------- | ---- | ------------------ | ------------ | -------------- |
| private | Y    |                    |              |                |
| 默认的  | Y    | Y                  |              |                |
| protect | Y    | Y                  | Y            |                |
| public  | Y    | Y                  | Y            | Y              |

- 数据类型

- 基本数据类型

- 基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成。

- valueOf() 方法的实现比较简单，就是先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容。

- 基本类型对应的缓冲池如下:

| name            | value                  |
| --------------- | ---------------------- |
| boolean         | true and false         |
| all byte values | all byte values        |
| short           | between -128 and 127   |
| int             | between -128 and 127   |
| char            | range \u0000 to \u007F |

- 引用数据类型

- 类 接口 数组

- String 类型

  - String 被声明为 final，因此它不可被继承。

  - 内部使用 char 数组存储数据，该数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组。并且 String 内部没有改变 value 数组的方法，因此可以保证 String不可变。

  - String,StringBuilder，StringBuffer

- String 
  - 线程安全

- StringBuilder
  -  线程不安全

- StringBuffer
  -  线程安全,内部使用synchronized 进行同步

- java中方法的传递是按值传递 引用类型传递的是地址值
  - 按值传递表示的是当前传递参数的值的副本

- 继承
  - 使用extends 关键字 是一种描述两个类之间的关系

- 抽象类与接口
  - 抽象类
  - 抽象类和抽象方法都使用 abstract 关键字进行声明。抽象类一般会包含抽象方法，抽象方法一定位于抽象类中。
  - 抽象类和普通类最大的区别是，抽象类不能被实例化，需要继承抽象类才能实例化其子类。

- 接口

  - 接口是抽象类的延伸，在 Java 8 之前，它可以看成是一个完全抽象的类，也就是说它不能有任何的方法实现。

  - 从 Java 8 开始，接口也可以拥有默认的方法实现，这是因为不支持默认方法的接口的维护成本太高了。在 Java 8 之前，如果一个接口想要添加新的方法，那么要修改所有实现了该接口的类。

  - 接口的成员(字段 + 方法)默认都是 public 的，并且不允许定义为 private 或者 protected。

  - 接口的字段默认都是 static 和 final 的。

  - 抽象类和接口比较

  - 从设计层面上看，抽象类提供了一种 IS-A 关系，那么就必须满足里式替换原则，即子类对象必须能够替换掉所有父类对象。而接口更像是一种 LIKE-A 关系，它只是提供一种方法实现契约，并不要求接口和实现接口的类具有 IS-A 关系。

  - 从使用上来看，一个类可以实现多个接口，但是不能继承多个抽象类。

  - 接口的字段只能是 static 和 final 类型的，而抽象类的字段没有这种限制。

  - 接口的成员只能是 public 的，而抽象类的成员可以有多种访问权限。

- 使用

  - 多数情况，接口的使用优先于抽象类，因为抽象类的使用是基于较为严格的继承关系，而接口可以较为灵活的提供的一个新的方法

  - Object 通用方法

- super

  - 访问父类的构造函数，委托父类完成初始化工作

  - 实现父类的方法后，可以通过super方法访问父类的方法

- override(重写) 和overload(重载)

  -  重写(Override)

    - 存在于继承体系中，指子类实现了一个与父类在方法声明上完全相同的一个方法。

    - 为了满足里式替换原则，重写有有以下两个限制:

    - 子类方法的访问权限必须大于等于父类方法；

    - 子类方法的返回类型必须是父类方法返回类型或为其子类型。

    - 使用 @Override 注解，可以让编译器帮忙检查是否满足上面的两个限制条件。

  -  重载(Overload)

    - 存在于同一个类中，指一个方法与已经存在的方法名称上相同，但是参数类型、个数、顺序至少有一个不同。

    - 应该注意的是，返回值不同，其它都相同不算是重载。

- equals 方法

  - 自反性 
    - x.equals(x);

  - 对称性
    - x.equals(y) == y.equals(x);

  - 传递性
    - if (x.equals(y) && y.equals(z)) x.equals(z);

  - 一致性 多次调用结果不变
    - x.equals(y) == x.equals(y);

  - 与null 比较

    - 对任何不是 null 的对象 x 调用 x.equals(null) 结果都为 false

    - x.equals(null)

  - 相比与==
    - 对于基本类型，== 判断两个值是否相等，基本类型没有 equals() 方法。
  - 对于引用类型，== 判断两个变量是否引用同一个对象，而 equals() 判断引用的对象是否等价。

- hashCode() 方法

  - hashCode() 返回散列值，而 equals() 是用来判断两个对象是否等价。等价的两个对象散列值一定相同，但是散列值相同的两个对象不一定等价。

  - 在覆盖 equals() 方法时应当总是覆盖 hashCode() 方法，保证等价的两个对象散列值也相等。

- toString()方法
  - 默认返回 ToStringExample@4554617c 这种形式，其中 @ 后面的数值为散列码的无符号十六进制表示。

- clone()
  - clone()是 Object 的 protected 方法，它不是 public，一个类不显式去重写 clone()，其它类就不能直接去调用该类实例的 clone() 方法。

- clone() 方法并不是 Cloneable 接口的方法，而是 Object 的一个 protected 方法。Cloneable 接口只是规定，如果一个类没有实现 Cloneable 接口又调用了 clone() 方法，就会抛出 CloneNotSupportedException。

- 浅拷贝
  - 拷贝对象和原始对象的引用类型引用同一个对象。

- 深拷贝
  - 拷贝对象和原始对象的引用类型引用不同对象。

- 使用 clone() 方法来拷贝一个对象即复杂又有风险，它会抛出异常，并且还需要类型转换。Effective Java 书上讲到，最好不要去使用 clone()，可以使用拷贝构造函数或者拷      贝工厂来拷贝一个对象。

- final

  - 数据

    - 声明数据为常量，可以是编译时常量，也可以是在运行时被初始化后不能被改变的常量。

    - 对于基本类型，final 使数值不变；

    - 对于引用类型，final 使引用不变，也就不能引用其它对象，但是被引用的对象本身是可以修改的。

  - 方法
    - 方法不能被子类重写

- 类
  - 类被final 声明，则不能被继承

- static

  - 静态变量 
    - 又称为类变量，也就是说这个变量属于类的，类所有的实例都共享静态变量，可以直接通过类名来访问它；静态变量在内存中只存在一份。
    - 每创建一个实例就会产生一个实例变量，它与该实例同生共死。

  - 静态方法

    - 在类加载的时候就存在了，它不依赖于任何实例。所以静态方法必须有实现，也就是说它不能是抽象方法(abstract)。

    - 只能访问所属类的静态字段和静态方法，方法中不能有 this 和 super 关键字。

  - 静态代码块
    - 静态语句块在类初始化时运行一次。

  - 静态内部类
    - 非静态内部类依赖于外部类的实例，而静态内部类不需要。静态内部类不能访问外部类的非静态的变量和方法。

  - 静态导包

  - 在使用静态变量和方法时不用再指明 ClassName，从而简化代码，但可读性大大降低。

- 初始化顺序

  - 存在继承的情况下

    - 父类(静态变量、静态语句块)

    - 子类(静态变量、静态语句块)

    - 父类(实例变量、普通语句块)

    - 父类(构造函数)

    - 子类(实例变量、普通语句块)·

    - 子类(构造函数)

- Comparable和Comparator区别比较

  - Comparable是排序接口，若一个类实现了Comparable接口，就意味着“该类支持排序”。而Comparator是比较器，我们若需要控制某个类的次序，可以建立一个“该类的比较器”来进行排序。

  - Comparable相当于“内部比较器”，而Comparator相当于“外部比较器”。

  - 两种方法各有优劣， 用Comparable 简单， 只要实现Comparable 接口的对象直接就成为一个可以比较的对象，但是需要修改源代码。 用Comparator 的好处是不需要修改源代码， 而是另外实现一个比较器， 当某个自定义的对象需要作比较的时候，把比较器和对象一起传递过去就可以比大小了， 并且在Comparator 里面用户可以自己实现复杂的可以通用的逻辑，使其可以匹配一些比较简单的对象，那样就可以节省很多重复劳动了。