# JVM垃圾回收

##### 对象回收算法

- 引用计数法

- 给对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。

- 两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。正因为循环引用的存在，因此 Java 虚拟机不使用引用计数算法。

- 可达性分析算法

- 通过 GC Roots 作为起始点进行搜索，能够到达到的对象都是存活的，不可达的对象可被回收。

![img](https://vipkshttps6.wiz.cn/editor/389f1850-89b1-11ec-ba6c-21d96952d446/5c9438e2-c60d-4229-8218-17f480ece95a/resources/p1pUWtZPEC0YDyPiJAoLvdeIAJIZn-xBWRqUPNt8Pm4.svg?token=W.nD2mE1u5uLp1pr17MNgFkfQGCNNODlvSlyrRmJ2hqvo5PfpWu4WWmHZpGX7Roq4)

- 虚拟机栈中引用的对象

- 本地方法栈中引用的对象

- 方法区中类静态属性引用的对象

- 方法区中的常量引用的对象

- 方法区的回收

- 主要是对常量池的回收和对类的卸载。

- 类的卸载条件很多

- 该类所有的实例都已经被回收，也就是堆中不存在该类的任何实例。

- 加载该类的 ClassLoader 已经被回收。

- 该类对应的 Class 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法

- finalize

- finalize() 类似 C++ 的析构函数，用来做关闭外部资源等工作。

##### 对象的引用类型

- 强引用

- 被强引用关联的对象不会被回收。

- 软引用

- 内存不够的时候被回收

- 弱引用

- 被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前。

- 虚引用

- 幽灵引用或者幻影引用。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用取得一个对象。

##### 垃圾回收算法

- 标记清除算法

- 标记整理算法

- 标记复制算法

- 分代收集算法